header(am-HomepageHero)
  h1(am-type="light")
    span(am-type="h0 middle") [
    span(am-type="h1 middle") AMCSS
    span(am-type="h0 middle") ]
  h2(am-type="h3 light italic" am-layout="pt2")
    span(am-type="normal") Attribute Modules
    |  for CSS
main
  section(am-Example)
    :markdown
      Attribute Modules (AM) is a technique for using **attributes** and their **values** rather than classes for styling HTML elements. In doing so, each attribute effectively declares a separate namespace for encapsulating style information, resulting in more readable, maintainable HTML & CSS.

      For an introduction to how AM was developed, see the [original blog post](http://glenmaddern.com/articles/introducing-am-css). The [specification itself](http://amcss.github.io/) is available on GitHub.

  section(am-Example)
    h3
      span(am-type="bold") Example:
      |  Bootstrap Buttons
    :markdown
      Buttons are one of the strongest use-cases for AM. Here we've reproduced some of Bootstrap's button markup as an example. The problem with this (and other BEM-style button patterns) is that the markup is heavily convention-based: all buttons require a `btn` class *and* a specific button class, and it results in cluttered markup.

      The AM version, in contrast, uses the attribute `am-Button` as an identifier, and allows straightforward, natural language as modifiers, e.g. `large`, `primary`, etc.
    pre: code
      span(am-Code='comment')= '<!-- Large primary button -->\n'
      = '<a '
      span(am-Code='removed')= 'class="btn btn-primary btn-lg"'
      = '>Large primary button</a>\n'
      = '<a '
      span(am-Code='added')= 'am-Button="primary large"'
      = '>Large primary button</a>\n'
      span(am-Code='comment')= '\n<!-- Default button -->\n'
      = '<a '
      span(am-Code='removed')= 'class="btn btn-default"'
      = '>Default button</a>\n'
      = '<a '
      span(am-Code='added')= 'am-Button'
      = '>Default button</a>\n'
      span(am-Code='comment')= '\n<!-- Small info button -->\n'
      = '<a '
      span(am-Code='removed')= 'class="btn btn-info btn-sm"'
      = '>Small info button</a>\n'
      = '<a '
      span(am-Code='added')= 'am-Button="info small"'
      = '>Small info button</a>\n'
      span(am-Code='comment')= '\n<!-- Extra-small danger button -->\n'
      = '<a '
      span(am-Code='removed')= 'class="btn btn-danger btn-xs"'
      = '>Extra-small danger button</a>\n'
      = '<a '
      span(am-Code='added')= 'am-Button="danger extra-small"'
      = '>Extra-small danger button</a>'

    p The CSS changes are quite straightforward:
    pre: code
      span(am-Code='removed')= '.btn'
      = ' '
      span(am-Code='added')= '[am-Button]'
      = ' { '
      span(am-Code='comment')= '/* Default button styles */'
      = ' }\n'
      span(am-Code='removed')= '.btn-primary'
      = ' '
      span(am-Code='added')= '[am-Button~="primary"]'
      = ' { '
      span(am-Code='comment')= '/* Primary colours */'
      = ' }\n'
      span(am-Code='removed')= '.btn-large'
      = ' '
      span(am-Code='added')= '[am-Button~="large"]'
      = ' { '
      span(am-Code='comment')= '/* Large sizing */'
      = ' }\n'

  section(am-Example)
    h3
      span(am-type="bold") Example:
      |  Flexbox Grid
    :markdown
      Using a grid system is commonplace and Flexbox Grid is one we're particularly fond of, but it shares some problems with all class-based grid systems. Because grid classes are used so frequently, it uses relatively *bare* css classes like `row` & `reverse`, but because columns need to be responsive, it eschews a global `col` class and instead defines `col-breakpoint-number` classes.

      Converting this to AM-style, on the other hand, we can use an `am-Row` and `am-Column` module, and since each of those define a namespace, we can be free to use values of our choosing. It's also simple to use characters that normally wouldn't suit classes, so we can use a `breakpoint:number` syntax, which is arguably easier to understand at a glance.
    pre: code
      = '<div '
      span(am-Code='removed')= 'class="row"'
      = ' '
      span(am-Code='added')= 'am-Row'
      = '>\n  <div '
      span(am-Code='removed')= 'class="col-xs-12 col-sm-8"'
      = ' '
      span(am-Code='added')= 'am-Column="xs:12 sm:8"'
      = '\n    <div '
      span(am-Code='removed')= 'class="box"'
      = ' '
      span(am-Code='added')= 'am-Demo="box"'
      = '>Responsive</div>'
      = '\n  </div>'
      = '\n</div>'

  section(am-Example)
    h3
      span(am-type="bold") Example:
      |  Traits
    :markdown
      While AM can be used as a drop-in for BEM-style class naming, you can also consider a module defining a more general *namespace* for grouping related styles. Similar to utility classes in Suit CSS, these can be thought of as reusable style **traits**, that can be applied on or within components.
    pre: code
      = '<div '
      span(am-Code='removed')= 'class="u-posAbsoluteCenter"'
      = ' '
      span(am-Code='added')= 'am-position="absolute center"'
      = '>\n  <div '
      span(am-Code='removed')= 'class="u-textTruncate u-textCenter"'
      = ' '
      span(am-Code='added')= 'am-text="truncate center"'
      = '>\n    Very centered text.\n  </div>'
      = '\n</div>'
    :markdown
      Here, we're able to make use of the fact that values for `am-position` and `am-text` operate in *different namespaces*, so we can use the value `center` in both places without worrying about naming clashes.
